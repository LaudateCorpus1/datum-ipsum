package com.intuit.datum_ipsum.model;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.codehaus.jettison.json.JSONArray;
import org.codehaus.jettison.json.JSONException;
import org.codehaus.jettison.json.JSONObject;
import org.codehaus.jettison.json.JSONStringer;
import org.codehaus.jettison.json.JSONWriter;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

/** Mid level object in the string representation.
 *
 * A sequence is comprised of an ordered list of wheels. Each wheel contains a set of blocks.
 * Think of wheels like the spinners on the slot machine, randomizing which block appears in each slot.
 */
public class Wheel implements Serializable {
    private Map<BlockDefinition, Block> blocks = new LinkedHashMap();


    /** @return blocks contained in this wheel */
    public Map<BlockDefinition, Block> getBlocks() {
        return blocks;
    }
    /** Add a block to this wheel.
     *  If the block definition is new, the block is inserted.
     *  If the block definition is already represented in this wheel, the two similar blocks are merged,
     *  with the appropriate values aggregated.
     *
     * @param block new block to include in this wheel
     */
    public void addBlock(Block block) {
        BlockDefinition definition;
        if (block.isDefaultBlock()) {
            definition = new BlockDefinition();
        } else {
            definition = block.getDefinition();
        }
        // insert new block or merge with existing block sharing same definition
        if (blocks.keySet().contains(definition)) {
            blocks.get(definition).reduce(block);
        } else {
            blocks.put(definition, block);
        }
    }

    /** @return total number of strings characterized by this wheel */
    public Integer getTotalBlockCounts() {
        Integer blockTotalCount = 0;
        for (Block block : blocks.values()) {
            blockTotalCount += block.getBlockCount();
        }
        return blockTotalCount;
    }


    /** Create an empty wheel. */
    public Wheel() {
        super();
    }

    /** Create a wheel from a single block.
     *
     * @param block the initial block
     */
    public Wheel(Block block) {
        super();
        this.addBlock(block);
    }


    /** Combine another wheel into this one by aggregating counts at each level (wheel, block).
     *
     * @param other the other wheel to combine
     */
    public void reduce(Wheel other) {
        if (other != null) {
            for (Block blockValue : other.getBlocks().values()) {
                this.addBlock(blockValue);
            }
        }
    }


    /** Generate a random string based on this wheel and a total string count (i.e. from a sequence).
     *
     * @param randomGenerator random number generator to use
     * @param totalCount total number of non-null strings (from the sequence);
     *                   used to determine if the result should be an empty string
     * @return the random string
     */
    public String generate(Random randomGenerator, Integer totalCount) {
        Integer totalBlockCount = this.getTotalBlockCounts();
        if (totalCount == null) {
            totalCount = totalBlockCount;
        }

        String result = "";
        Integer checkTotal = randomGenerator.nextInt(totalCount);
        // randomize if result is an empty string
        // based on comparison of sum of block counts to the total count
        if (checkTotal < totalBlockCount) {
            Integer randomInt = randomGenerator.nextInt(totalBlockCount);
            Integer cumulativeCount = 0;

            for (Block block : blocks.values()) {
                cumulativeCount += block.getBlockCount();
                if (randomInt < cumulativeCount) {
                    result = block.generate(randomGenerator);
                    break;
                }
            }
        }

        return result;
    }

    /** Generate a random string based on this wheel.
     *
     * @param randomGenerator random number generator to use
     * @return the random string
     */
    public String generate(Random randomGenerator) {
        return generate(randomGenerator, null);
    }


    /** Calculate the probability of a portion of the given string being generated by this wheel.
     *  Attempts to greedily match characters starting at the beginning of the string.
     *  Removes matched characters from inputCharacters so the process can be repeated with the next wheel.
     *
     * @param inputCharacters characters to match
     * @return the probability of generating the matching portion of the string
     */
    public Double calculateLikelihood(List<Character> inputCharacters) {
        StringBuilder builder = new StringBuilder();
        for (Character character : inputCharacters) {
            builder.append(character);
        }
        String input = builder.toString();

        // for each block, count the maximum number of character that can be matched to that block
        Integer maxNumGathered = 0;
        Map<BlockDefinition, Integer> numsGathered = new HashMap();
        for (Map.Entry<BlockDefinition, Block> entry : blocks.entrySet()) {
            Integer numGathered = entry.getValue().getGatherCount(input);
            numsGathered.put(entry.getKey(), numGathered);
            maxNumGathered = Math.max(maxNumGathered, numGathered);
        }
        // take the maximum set of matched characters
        List<BlockDefinition> eligibleBlocks = new ArrayList();
        for (Map.Entry<BlockDefinition, Integer> entry : numsGathered.entrySet()) {
            if (entry.getValue().equals(maxNumGathered)) {
                eligibleBlocks.add(entry.getKey());
            }
        }

        String maxInput = input.substring(0, maxNumGathered);

        // sum probabilities across blocks that can match this set of characters
        Double likelihood = 0.;
        Integer totalBlockCount = this.getTotalBlockCounts();
        for (BlockDefinition definition : eligibleBlocks) {
            Block block = blocks.get(definition);
            likelihood += block.calculateLikelihood(maxInput) * 1.*block.getBlockCount()/totalBlockCount;
        }

        // remove matched characters
        for (Integer count = 0; count < maxNumGathered; count++) {
            inputCharacters.remove(0);
        }
        return likelihood;
    }


    /** Serialize this wheel to a JSON string.
     *
     * @return the JSON string
     * @throws JSONException
     */
    public String toJSONString() throws JSONException {
        JSONWriter stringer = new JSONStringer();
        appendToJSON(stringer);
        return stringer.toString();
    }
    void appendToJSON(JSONWriter json) throws JSONException{
        json.object(); // Outer object
        json.key("blocks").array();
        for (Block block : blocks.values()) {
            block.appendToJSON(json);
        }
        json.endArray();
        json.endObject(); // End outer
    }

    /** Deserialize a wheel from a JSON string
     *
     * @param jsonString the JSON string
     * @return a wheel object represented by the string
     * @throws JSONException
     */
    static public Wheel fromJSONString(String jsonString) throws JSONException {
        return fromJSON(new JSONObject(jsonString));
    }
    static Wheel fromJSON(JSONObject json) throws JSONException {
        Wheel output = new Wheel();
        JSONArray blocksJSON = json.optJSONArray("blocks");
        if (blocksJSON == null) {
            throw new JSONException("Missing array for key \"blocks\".");
        }
        Block block;
        for (Integer index = 0; index < blocksJSON.length(); index ++) {
            block = Block.fromJSON(blocksJSON.getJSONObject(index));
            output.addBlock(block);
        }
        return output;
    }

    @Override
    public String toString() {
        return "Wheel [blocks=" + blocks.toString()
                + "]";
    }

    @Override
    public int hashCode() {
        return new HashCodeBuilder(1, 31).append(blocks).toHashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) return false;
        if (obj == this) return true;
        if (!(obj instanceof Wheel)) return false;
        Wheel other = (Wheel) obj;
        return new EqualsBuilder().append(blocks, other.getBlocks()).isEquals();
    }
}
